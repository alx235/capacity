Requirements for Container Elements (http://www.ccplusplus.com/2014/01/stl-container-element-c.html):
- An element must be copyable by a copy constructor
- An element must be assignable by the assignment operator
- An element must be destroyable by a destructor

itearator template wrapper of array Type T.

ref<->pointer:
	int* a = new int(1);
	int& a1 = *a;
	int* b = &a1;

Pol. run-time: truncation if base b = d (derived); 

    object types with virtual functions are usually implemented in C++ with a per-object pointer
    to a table of virtual functions which is unique to each type
    So, that's why we use ref and pointer.

explicit: (Meyers): use explicit any time when have no reason don't use it.
problem: cost for temporary object, unpredictable complicated implisit cast; including implicit POD type.
/*
class String {
public:
    String(int n); // allocate n bytes to the String object
    String(const char *p); // initializes object with char *p
};
Now if you try

String mystring = 'x';
the char 'x' will be implicitly converted to int and then will call the String(int) constructor. 

  !!!But this is not what the user might have intended. So to prevent such conditions, 
  we shall define the constructor as explicit:

class String {
public:
    explicit String (int n); //allocate n bytes
    String(const char *p); // initialize sobject with string p
};*/

Defaults params are early binding ( at compile time ) , and virtual functions - later, important for def virt fucnt. params.

compiler forbid const ref ref to temporary object

All objects originally non-const.

Invoking delete on a pointer not allocated dynamically using new is something called Undefined Behavior

destruction:

~derived
~member derived
~base
~member base

constructor have reverse order.

dynamic lib - load to memory while it not full and has no new(allocation) request. It's binar code (dll,so,etc), run-time
static - compile time binar code, application binar grow, ref undef before compile.
Why? not write&compile every time same code...some time init lib is expensive. 

const and typedef - internal link (C compatibility)
inline must be defined in each translation unit when it declared
external C/{} - link C compatible code (binar), have no influence on call's semantics, but have on type safe, memory/stack loc. etc.
 compiler need .h, linker libs
 - NOT use for diff.
      C++ compilers!!!
preprocessor make macroreplace and insert from include sorces...and check path of sources
compiler check declaration rule
linker check other rule and multiple different translation unit
 each declaration (can be separate) must have only one definiton
  BUT:
  ODR: two def mean one if:
   -located in another transl unit
   -identical by lexeme
   -has same mean(typedef) in each transl unit
process of destroying local objects and calling destructors is called stack unwinding
if throw() list of funct except has another type except it cause unexpected() => terminate => abort,
 if exception spec list is empty => no except
  exit() call only static var destr
  abort() ignore all
?ABORT/EXIT LEAVE STACK...MAYBE GOTO...
?replacement funct MUST have more specialization list of exception

С++ no virtual constructor (ONLY VIRTUAL FABRIC METHOD,ex below) 

defenition constant in header file cause effective compilator code

<const_cast>/mutable(const modification member) - guess for what)

s=q or s(q) call member-by-member copy of all bit from one to another

s==q? maybe some bit compare?

nonlocal static var call constr in def order in bound of translation unit to guaranted out use static flag (keep state)
- first flag use strategy or ...static int x = 0;...
- local static var. init first time (control flow) cross defenition, after call main(...) counter, nonlocal init before,
in all case destructor call after main(..) except some abnormal program complete
temporary object can't link with non-const reference? (maybe because this type object can't be lvalue?,
 and const ref is not obliged to check this condition)

FORBIDDEN overload: ::, ., .*, ?;, sizeof, typeid.

Unar/binar oper can be overloaded with non-static member(0,1 argc) or global funct (1, 2 argc),
 local have no precedent this case, unar firs arg CAN'T be POD type

Overload operatos: =,[],(),-> only non-static member;
 () - functional object
 ->defer pointer or iterator

friend mod => function get access only in hide scope of class (example in MYstring)

IMPLICIT CONVERSION NOT ALLOWED WITH NON_CONST REF FUNC ARGS

POSTFIX OVERLOAD operator have signature with int arg, it's value has no mean..., it's only signature and all.

Exception in destructor call terminate() which call abort() - so it bad, because memory will not free.
 alloc memory, constr.
 destr., dealloc memory

Function() = 0 - pure virtual => abstract class (can't create object)

Fucntion Signature Throw (specif. excep.) call std::unexpected if throw except that not belong to list of except below,
which cal terminate().

CATCH Derived except cancel CATCH of BASE except (in def order).

When a THROW expression is evaluated, an exception object is initialized
 from the value of the expression.
 The exception object which is thrown gets its type from the static type
 of the throw expression ignoring any const and volatile qualifiers.
 For class types this means that copy-initialization is performed

FABRIC METHOD: definite abstract class with virtual T_BASE* function=0,
return T_SOME_DERIVED* in override - just interface returning base class pointer.
it is more efficient to do ++iterator than iterator++ since it avoids an 
unnecessary copy when incrementing

COMPILER CAN DETERMINE PARAM TYPE by ARG TYPE RESPECTIVILY

INSTANTIATION POINT TEMPLATE - FIRST DEFENITE PARAM TYPE
 CLASS C=CHAR => WE CAN OMIT PARAM TYPE IN INSTANTIATION

MORE SPECIAL TEMPLATE VERSION HAS PRIOR FOR DECLAR OBJ, POINTER
 AND OVERLOAD RESOLUTION, PARTIAL SPECIALIZATION MUST!!! BE ABOVE COMPLETE=>
 ORDER IMPORTANT!!!

COMPILE-TIME(PARAMETRIC) POLYMORPHISM - TEMPLATE AND INHERITANCE
RUN-TIME POLYMORPHISM - VIRTUAL FUNCTION AND OBJECT INHERITANCE

IN GENERAL, GENERIC FROM ONE TEMPLATE 2 TYPES HAVE NO REFERENCE.

DECLARE USING INSIDE CLASS USE FOR OVERLOAD BASE OR DERIVED MEMBERS.

FOR BASE CLASS CASE USE EXPLICIT CLOSE DERIVED DEFINITON OR
USE VIRTUAL BASE CLASS (:VIRTUAL _base_)...for cast

2 REPLACEMENT FUNCTIONS USING IN MULTIPLE INHERITANCE LEAD TO AMBIGUITY.

dynamic_cast<T*>(D*): downcast(if inheritance), upcast and crosscast need polymorthic type D, if fail =0
 for & => bad_cast exception
 for virtual base (multiple inheritance) can be ambiguity (what object???)
 dynamic_cast<void*>(D*) give adress of object beginning (pol. type)
 static_cast - for void* to T* cast
  void* pointer can be used for any standart pointer operation only static_cast
 const_cast full save only in case when object declare as non-const(volatile)
typeid: return pointer to type info (std type), bad_type if for zero pol type pointer or ref, compil-time value for non-pol type


pointer to VIRTUAL member need to get it from one adress space to another with condition of equal same type location,
because of pointer of virtual member like offset in array

predicat - just function return bool

for_each - cycle alternative

copy? + push_back - protected from out_range

STD::ALGORITMS - NEED (IF NEED...because of standart case implementation) EXAMPLE

iterator - just pointer to array wrapper, which has const time operation (not sure about [] for random access).

Memory allocator (+d.3.5) is complex and non-trivial topic, need test, experience..so i can't say that it'll done near future.

bit field (int:1(2), bool name:1), or union for save memory do not give guarantee of portability,  but save memory.

Widget w3 = w2; // call copy constructor! (first init)

local static order init in diff. transl unit = undefined

forbid copy constr and operator assignment = inherit from class with private copy constr and operator assignment

never call virt function in constructor and destructor - when creating derived object object type is base...so undefined beh
can exist...

use special smart pointer to dynamic array

//получения доступа к ресурсу в конструкторе, а освобождения — в деструкторе соответствующего класса
+RAII - Resource Acquision is Initialization - forbid copy operations or ref counter//

pointer def value is NOT ALWAYS NULL.

deref NULL pointer take no effect.

Place dynamic object into separate location to avoid memory leaks (just not forget free resource)

+To avoid duplicate code in const/non-const member use const_cast

+/- return object not ref because of lost ref problem => Mayers said that compiler will resolve this problem (don't think this
always happen, but be carefull!)

+Always use const if can, for save...

+Use non-member fuction for case when need cast all params.

PARTIAL SPECIALIZATION for template function is FORBID

+Use init cur val instead of def constr and init...(free processor time)

private inheritance forbid cast from derived to base

+VIRTUAL INHERITANCE is very expensive and low!

+CLASS AND TYPENAME ARE EQUAL KEYWORD!

User type POD type not use constructor

ref(&a) link with lvalue;
