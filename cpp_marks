

dynamic lib- load to memory one time?
static - load to memory every time

const and typedef - internal link
inline must be defined in each translation unit when it declared
external C/{} - link C compatible code, have no influence on call's semantics, but have on type safe, etc.
compiler need .h, linker libs
preprocessor make macroreplace and insert from include sorces
compiler check declaration rule
linker check other rule and multiple different translation unit
each declaration (can be separate) must have only one definiton

ODR: two def mean one if:
-located in another transl unit
-identical by lexeme
-has same mean(typedef) in each transl unit

process of destroying local objects and calling destructors is called stack unwinding
if throw() list of funct except has another type except it cause unexpected() => terminate => abort,
if exception spec list is empty => no except
exit() call only static var destr
abort() ignore all
ABORT/EXIT LEAVE STACK...MAYBE GOTO...
replacement funct MUST have more sprecialization list of exception

ะก++ no virtual constructor

defenition constant in header file cause effective compilator code

<const_cast>/mutable(const mod member) - guess for what)

s=q or s(q) call member-by-member copy of all bit from one to another

s==q? maybe some bit compare?

extern "C" - only linker rule. Why? because diiferent lang (comp) have diff way of location memory,
 procc stack,  etc.. So you say link "it" in C rule (for compatibility) - NOT use for diff.
 C++ compilers!!!

nonlocal static var call constr in def order in bound of translation unit to guaranted out use static flag (kkeep state) - first flag use strategy or ...static int x = 0;... - init first time control flow cross defenition, after call main(...) counter, nonlocal init before, in all case destructor call after main(..) except some abnormal program complete
temporary object can't link with non-const reference? (maybe because this type object can't be lvalue?, and const ref is not obliged to check this condition)

FORBIDDEN overload: ::, ., .*, ?;, sizeof, typeid.

Unar/binar oper can be overloaded with non-static member(no,1 argc) or global funct (1, 2 argc), local have no precedent this case, unar firs arg CAN'T be POD type

Overload operatos: =,[],(),-> only non-static member;

friend mod => function get access only in hide scope of class (don't understand nothing...)

IMPLICIT CONVERSION NOT ALLOWED WITH NON_CONST REF FUNC ARGS

POSTFIX OVERLOAD operator have signature with int arg, it's value has no mean..., it's only signature and all.

Exception in destructor call terminate() which call abort()

Fucntion Signature Throw (specif. excep.) call std::unexpected if throw except that not belong to list of except below, which cal terminate().

CATCH Derived except cancel CATCH of BASE except (in def order).

When a THROW expression is evaluated, an exception object is initialized
 from the value of the expression.
 The exception object which is thrown gets its type from the static type
 of the throw expression ignoring any const and volatile qualifiers.
 For class types this means that copy-initialization is performed

FABRIC METHOD: definite abstract class with virtual T_BASE* function=0,
return T_SOME_DERIVED* in override - just interface returning base class pointer.
it is more efficient to do ++iterator than iterator++ since it avoids an 
unnecessary copy when incrementing

COMPILER CAN DETERMINE PARAM TYPE by ARG TYPE RESPECTIVILY

INSTANTIATION POINT TEMPLATE - FIRST DEFENITE PARAM TYPE

CLASS C=CHAR => WE CAN OMIT PARAM TYPE IN INSTANTIATION

MORE SPECIAL TEMPLATE VERSION HAS PRIOR FOR DECLAR OBJ, POINTER
AND OVERLOAD RESOLUTION, PARTIAL SPECIALIZATION MUST!!! BE ABOVE COMPLETE=>
ORDER IMPORTANT!!!

COMPILE-TIME(PARAMETRIC) POLYMORPHISM - TEMPLATE AND INHERITANCE
RUN-TIME POLYMORPHISM - VIRTUAL FUNCTION AND OBJECT INHERITANCE

IN GENERAL, GENERIC FROM ONE TEMPLATE 2 TYPES HAVE NO REFERENCE.

DECLARE USING INSIDE CLASS USE FOR OVERLOAD BASE OR DERIVED MEMBERS.

FOR BASE CLASS CASE USE EXPLICIT CLOSE DERIVED DEFINITON OR
USE VIRTUAL BASE CLASS (:VIRTUAL _base_).

2 REPLACEMENT FUNCTIONS USING IN MULTIPLE INHERITANCE LEAD TO AMBIGUITY.


dynamic_cast<T*>(D*): downcast(if inheritance), upcast and crosscast need polymorthic type D, if fail =0
for & => bad_cast exception
for virtual base (multiple inheritance) can be ambiguity (what object???)
dynamic_cast<void*>(D*) give adress of object beginning (pol. type)
static_cast - for void* to T* cast
const_cast full save only in case when object declare as non-const(volatile)
typeid: return pointer to type info (std type), bad_type if for zero pol type pointer or ref, compil-time value for non-pol type


pointer to VIRTUAL member need to get it from one adress space to another with condition of equal same type location,
because of pointer of virtual member like offset in array

predicat - just function return bool

for_each - cycle alternative

copy + push_back - protected from out_range

STD::ALGORITMS - NEED (IF NEED...because of standart case implementation) EXAMPLE

iterator - just pointer to array wrapper, which has const time operation (not sure about [] for random access).


Memory allocator (+d.3.5) is complex and non-trivial topic, need test, experience..so i can't say that it'll done near future.

bit field (int:1(2), bool name:1), or union for save memory do not give guarantee of portability.

Widget w3 = w2; // call copy constructor!

local static order init in diff. transl unit = undefined

forbid copy constr and operator assignment = inherit from class with private copy constr and operator assignment

never call virt function in constructor and destructor - when creating derived object object type is base...so undefined beh
can exist...

use special smart pointer to dynamic array

RAII - Resource Acquision is Initialization - forbid copy operations or ref counter

Place dynamic object into separate location to avoid memory leaks

To avoid duplicate code in const/non-const member use const_cast

return object not ref because of lost ref problem => Mayers said that compiler will resolve this problem (don't think thid
always happen, but be carefull!)

Always use const if can for save...

Use non-member fuction for case when need cast all params.

PARTIAL SPECIALIZATION for template function is FORBID

Use init cur val instead of def constr and init.

private inheritance forbid cast from derived to base

VIRTUAL INHERITANCE is very expensive and low!
